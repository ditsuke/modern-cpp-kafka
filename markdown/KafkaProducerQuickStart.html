
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>KafkaProducer Quick Start</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css" integrity="sha384-SI27wrMjH3ZZ89r4o+fGIJtnzkAnFs3E4qz9DIYioCQ5l9Rd/7UAa8DHcaL8jkWt" crossorigin="anonymous">
    <style>
      pre { background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; padding: 0.6em 1em; }
      h1,h2 { margin-top: 1em; }
      div.navbar { padding: 8px 0; }
      div.toc { float: right; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 id="kafkaproducer-quick-start"><a class="toclink" href="#kafkaproducer-quick-start">KafkaProducer Quick Start</a></h1>
<p>Generally speaking, The <code>modern-cpp-kafka API</code> is quite similar to the <a href="https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/producer/KafkaProducer.html">Kafka Java's API</a>.</p>
<p>We'd recommend users to cross-reference them, --especially the examples.</p>
<h2 id="kafkaproducer"><a class="toclink" href="#kafkaproducer">KafkaProducer</a></h2>
<ul>
<li>The <code>send</code> is an unblock operation, and the result (including errors) could only be got from the delivery callback.</li>
</ul>
<h3 id="example"><a class="toclink" href="#example"><a href="https://github.com/morganstanley/modern-cpp-kafka/blob/main/examples/kafka_async_producer_not_copy_payload.cc">Example</a></a></h3>
<div class="codehilite"><pre><span></span><code><span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">kafka</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">kafka</span><span class="o">::</span><span class="nn">clients</span><span class="o">::</span><span class="nn">producer</span><span class="p">;</span><span class="w"></span>



<span class="w">        </span><span class="c1">// Create configuration object</span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">Properties</span><span class="w"> </span><span class="nf">props</span><span class="w"> </span><span class="p">({</span><span class="w"></span>

<span class="w">            </span><span class="p">{</span><span class="s">&quot;bootstrap.servers&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">{</span><span class="n">brokers</span><span class="p">}},</span><span class="w"></span>

<span class="w">            </span><span class="p">{</span><span class="s">&quot;enable.idempotence&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="p">}},</span><span class="w"></span>

<span class="w">        </span><span class="p">});</span><span class="w"></span>



<span class="w">        </span><span class="c1">// Create a producer instance</span>

<span class="w">        </span><span class="n">KafkaProducer</span><span class="w"> </span><span class="nf">producer</span><span class="p">(</span><span class="n">props</span><span class="p">);</span><span class="w"></span>



<span class="w">        </span><span class="c1">// Read messages from stdin and produce to the broker</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;% Type message value and hit enter to produce message. (empty line to quit)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>



<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">             </span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">line</span><span class="p">);</span><span class="w"></span>

<span class="w">             </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="c1">// The ProducerRecord doesn&#39;t own `line`, it is just a thin wrapper</span>

<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ProducerRecord</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span><span class="w"></span>

<span class="w">                                         </span><span class="n">NullKey</span><span class="p">,</span><span class="w"></span>

<span class="w">                                         </span><span class="n">Value</span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="n">line</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()));</span><span class="w"></span>



<span class="w">            </span><span class="c1">// Send the message</span>

<span class="w">            </span><span class="n">producer</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">record</span><span class="p">,</span><span class="w"></span>

<span class="w">                          </span><span class="c1">// The delivery report handler</span>

<span class="w">                          </span><span class="c1">// Note: Here we capture the shared_pointer of `line`,</span>

<span class="w">                          </span><span class="c1">//       which holds the content for `record.value()`.</span>

<span class="w">                          </span><span class="c1">//       It makes sure the memory block is valid until the lambda finishes.</span>

<span class="w">                          </span><span class="p">[</span><span class="n">line</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">RecordMetadata</span><span class="o">&amp;</span><span class="w"> </span><span class="n">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Error</span><span class="o">&amp;</span><span class="w"> </span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                              </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                                  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;% Message delivered: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">metadata</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">                              </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                                  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;% Message delivery failed: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">message</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">                              </span><span class="p">}</span><span class="w"></span>

<span class="w">                          </span><span class="p">});</span><span class="w"></span>



<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>



<span class="w">        </span><span class="c1">// producer.close(); // No explicit close is needed, RAII will take care of it</span>
</code></pre></div>

<ul>
<li>
<p>User must guarantee the memory block for <code>ProducerRecord</code>'s <code>key</code> is valid until being <code>send</code>.</p>
</li>
<li>
<p>By default, the memory block for <code>ProducerRecord</code>'s <code>value</code> must be valid until the delivery callback is called; Otherwise, the <code>send</code> should be with option <code>KafkaProducer::SendOption::ToCopyRecordValue</code>.</p>
</li>
<li>
<p>It's guaranteed that the delivery callback would be triggered anyway after <code>send</code>, -- a producer would even be waiting for it before <code>close</code>. So, it's a good way to release these memory resources in the <code>Producer::Callback</code> function.</p>
</li>
</ul>
<h2 id="about-enablemanualeventspoll"><a class="toclink" href="#about-enablemanualeventspoll">About <code>enable.manual.events.poll</code></a></h2>
<p>While we construct a <code>KafkaProducer</code> with <code>enable.manual.events.poll=false</code> (the default option), an internal thread would be created for <code>MessageDelivery</code> callbacks handling.</p>
<p>This might not be what you want, since then you have to use 2 different threads to send the messages and handle the <code>MessageDelivery</code> responses.</p>
<p>Here we have another choice, -- using <code>enable.manual.events.poll=true</code>, thus the <code>MessageDelivery</code> callbacks would be called within member function <code>pollEvents()</code>.</p>
<ul>
<li>Note: if you constructed the <code>KafkaProducer</code> with <code>enable.manual.events.poll=true</code>, the <code>send()</code> will be an <code>unblocked</code> operation even if the <code>message buffering queue</code> is full. In that case, the <code>send()</code> operation would throw an exception (or return an <code>error code</code> with the input reference parameter), -- instead of blocking there. And you might want to call <code>pollEvents()</code>, thus delivery-callback could be called for some messages (which could then be removed from the <code>message buffering queue</code>).</li>
</ul>
<h3 id="example_1"><a class="toclink" href="#example_1">Example</a></h3>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">kafka</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">kafka</span><span class="o">::</span><span class="nn">clients</span><span class="o">::</span><span class="nn">producer</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="n">KafkaProducer</span><span class="w"> </span><span class="nf">producer</span><span class="p">(</span><span class="n">props</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">&quot;enable.manual.events.poll&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="p">));</span><span class="w"></span>



<span class="w">    </span><span class="c1">// Prepare &quot;msgsToBeSent&quot;</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">msgsToBeSent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>



<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msgsToBeSent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ProducerRecord</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span><span class="w"> </span><span class="n">partition</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">first</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">kafka</span><span class="o">::</span><span class="n">Error</span><span class="w"> </span><span class="n">sendError</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">producer</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">sendError</span><span class="p">,</span><span class="w"></span>

<span class="w">                      </span><span class="n">record</span><span class="p">,</span><span class="w"></span>

<span class="w">                      </span><span class="c1">// Ack callback</span>

<span class="w">                      </span><span class="p">[</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">RecordMetadata</span><span class="o">&amp;</span><span class="w"> </span><span class="n">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Error</span><span class="o">&amp;</span><span class="w"> </span><span class="n">deliveryError</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                           </span><span class="c1">// the message could be identified by `metadata.recordId()`</span>

<span class="w">                           </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">deliveryError</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"></span>

<span class="w">                               </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;% Message delivery failed: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">deliveryError</span><span class="p">.</span><span class="n">message</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">                           </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                               </span><span class="n">msgsToBeSend</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">recordId</span><span class="p">());</span><span class="w"> </span><span class="c1">// Quite safe here</span>

<span class="w">                           </span><span class="p">}</span><span class="w"></span>

<span class="w">                       </span><span class="p">});</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sendError</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>



<span class="w">    </span><span class="c1">// Here we call the `MessageDelivery` callbacks</span>

<span class="w">    </span><span class="c1">// Note: we can only do this while the producer was constructed with `enable.manual.events.poll=true`.</span>

<span class="w">    </span><span class="n">producer</span><span class="p">.</span><span class="n">pollEvents</span><span class="p">();</span><span class="w"></span>
</code></pre></div>

<h2 id="headers-in-producerrecord"><a class="toclink" href="#headers-in-producerrecord"><code>Headers</code> in <code>ProducerRecord</code></a></h2>
<ul>
<li>
<p>A <code>ProducerRecord</code> could take extra information with <code>headers</code>.</p>
<ul>
<li>Note: the <code>header</code> within <code>headers</code> contains the pointer of the memory block for its <code>value</code>. The memory block <strong>MUST</strong> be valid until the <code>ProducerRecord</code> is read by <code>producer.send()</code>.</li>
</ul>
</li>
</ul>
<h3 id="example_2"><a class="toclink" href="#example_2">Example</a></h3>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">kafka</span><span class="o">::</span><span class="nn">clients</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="n">kafak</span><span class="o">::</span><span class="n">producer</span><span class="o">::</span><span class="n">KafkaProducer</span><span class="w"> </span><span class="nf">producer</span><span class="p">(</span><span class="n">props</span><span class="p">);</span><span class="w"></span>



<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">producer</span><span class="o">::</span><span class="n">ProducerRecord</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span><span class="w"> </span><span class="n">partition</span><span class="p">,</span><span class="w"> </span><span class="n">Key</span><span class="p">(),</span><span class="w"> </span><span class="n">Value</span><span class="p">());</span><span class="w"></span>



<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msgsToBeSent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Prepare record headers</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">session</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">session</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">seqno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">seqno</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">record</span><span class="p">.</span><span class="n">headers</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;session&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">session</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="n">session</span><span class="p">.</span><span class="n">size</span><span class="p">()}</span><span class="w"> </span><span class="p">},</span><span class="w"></span>

<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;seqno&quot;</span><span class="p">,</span><span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">seqno</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">seqno</span><span class="p">)}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">};</span><span class="w"></span>



<span class="w">        </span><span class="n">record</span><span class="p">.</span><span class="n">setKey</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">key</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">record</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">value</span><span class="p">);</span><span class="w"></span>



<span class="w">        </span><span class="n">producer</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">record</span><span class="p">,</span><span class="w"></span>

<span class="w">                      </span><span class="c1">// Ack callback</span>

<span class="w">                      </span><span class="p">[</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">kafka</span><span class="o">::</span><span class="n">producer</span><span class="o">::</span><span class="n">RecordMetadata</span><span class="o">&amp;</span><span class="w"> </span><span class="n">metadata</span><span class="p">,</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">kafka</span><span class="o">::</span><span class="n">Error</span><span class="o">&amp;</span><span class="w"> </span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                           </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"></span>

<span class="w">                               </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;% Message delivery failed: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">message</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">                           </span><span class="p">}</span><span class="w"></span>

<span class="w">                       </span><span class="p">});</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div>

<h2 id="to-make-kafkaproducer-reliable"><a class="toclink" href="#to-make-kafkaproducer-reliable">To Make KafkaProducer Reliable</a></h2>
<p>While using message dispatching systems, we always suffer from message lost, duplication and disordering.</p>
<p>Since the application (using the <code>KafkaProducer</code>) might crash/restart, we might consider using certain mechanism to achieve <code>At most once</code>/<code>At least once</code>, and <code>Ordering</code>, -- such as locally persisting the messages until successful delivery, using embedded sequence number to de-duplicate, or responding data-source to acknowledgement the delivery result, etc. These are common topics, which are not quite specific to Kafka. </p>
<p>Here we'd focus on <code>KafkaProducer</code>, together with the <code>idempotence</code> feature. Let's see, in which cases problems might happen, how to avoid them, and what's the best practise,-- to achieve <code>No Message Lost</code>, <code>Exactly Once</code> and <code>Ordering</code>.</p>
<h3 id="no-message-lost"><a class="toclink" href="#no-message-lost">No Message Lost</a></h3>
<h4 id="how-could-a-message-be-lost-even-with-successful-delivery"><a class="toclink" href="#how-could-a-message-be-lost-even-with-successful-delivery">How could a message be lost even with successful delivery</a></h4>
<ul>
<li>
<p>First, the <code>partition leader</code> doesn't sync-up the latest message to enough <code>in-sync replicas</code> before responding with the <code>acks</code></p>
<ul>
<li>
<p>The <code>partition leader</code> just don't need to wait for other <code>replica</code>s response</p>
<ul>
<li>E.g, the producer is configured with <code>acks=1</code></li>
</ul>
</li>
<li>
<p>No available <code>in-sync replica</code> to wait for the response</p>
<ul>
<li>E.g, all other replicas are not in-sync and brokers are configured with <code>min.insync.replicas=1</code>)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Then, the <code>partition leader</code> crashes, and one <code>in-sync replica</code> becomes new <code>partition leader</code></p>
<ul>
<li>The new <code>partition leader</code> has no acknowledgement with the latest messages. Later, while new messages arrive, it would use conflicting record offsets (same with those records which the <code>partition leader</code> knows only). Then, even if the previous <code>partition leader</code> comes up again, these records have no chance to be recovered (just internally overwritten to be consistent with other replicas).</li>
</ul>
</li>
</ul>
<h4 id="how-to-make-sure-no-message-lost"><a class="toclink" href="#how-to-make-sure-no-message-lost">How to make sure <strong>No Message Lost</strong></a></h4>
<ul>
<li>
<p>Make sure the leader would wait for responses from all in-sync replicas before the response</p>
<ul>
<li>Configuration <code>acks=all</code> is a <strong>MUST</strong> for producer</li>
</ul>
</li>
<li>
<p>Ensure enough <code>In-Sync partition replicas</code></p>
<ul>
<li>
<p>Configuration <code>min.insync.replicas &gt;= 2</code> is a <strong>MUST</strong> for brokers</p>
<ul>
<li>
<p>Take <code>min.insync.replicas = 2</code> for example, it means,</p>
<ol>
<li>
<p>At most <code>replication.factor - min.insync.replicas</code> replicas are out-of-sync, -- the producer would still be able to send messages, otherwise, it could fail with 'no enough replica' error, and keeps retrying.</p>
</li>
<li>
<p>Occasionally no more than <code>min.insync.replicas</code> in-sync-replica failures. -- otherwise, messages might be missed. In this case, if just one in-sync replica crashes after sending back the ack to the producer, the message would not be lost; if two failed, it would! Since the new leader might be a replica which was not in-sync previously, and has no acknowledgement with these latest messages.</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Please refer to <a href="KafkaBrokerConfiguration.md">Kafka Broker Configuration</a> for more details.</p>
</li>
<li>
<p>Then, what would happen if replicas fail</p>
<ol>
<li>
<p>Fails to send (<code>not enough in-sync replica failure</code>), -- while number of <code>in-sync replicas</code> could not meet <code>min.insync.replication</code> </p>
</li>
<li>
<p>Lost messages (after sending messages), -- with no <code>in-sync replica</code> survived from multi-failures</p>
</li>
<li>
<p>No message lost (while with all <code>in-sync replicas</code> acknowledged, and at least one <code>in-sync replica</code> available)</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="exactly-once-ordering"><a class="toclink" href="#exactly-once-ordering">Exactly Once &amp; Ordering</a></h3>
<h4 id="how-duplications-happen"><a class="toclink" href="#how-duplications-happen">How duplications happen</a></h4>
<ul>
<li>After brokers successfully persisted a message, it sent the <code>ack</code> to the producer. But for some abnormal reasons (such as network failure, etc), the producer might fail to receive the <code>ack</code>. The <code>librdkafka</code>'s internal queue would retry, thus another (duplicated) message would be persisted by brokers.</li>
</ul>
<h4 id="how-disordering-happens-within-one-partition"><a class="toclink" href="#how-disordering-happens-within-one-partition">How disordering happens within one partition</a></h4>
<ul>
<li>
<p>The <code>librdkafka</code> uses internal partition queues, and once a message fails to be sent successfully(e.g, brokers are down), it would be put back on the queue and retries again while <code>retry.backoff.ms</code> expires. However, before that (retry with the failed message), the brokers might recover and the messages behind (if with configuration <code>max.in.flight &gt; 1</code>) happened to be sent successfully. In this case (with configuration <code>max.in.flight &gt; 1</code> and <code>retries &gt; 0</code>), disordering could happen, and the user would not even be aware of it.</p>
</li>
<li>
<p>Furthermore, while the last retry still failed, delivery callback would eventually be triggered. The user has to determine what to do for that (might want to re-send the message, etc). But there might be a case, -- some later messages had already been saved successfully by the server, thus no way to revert the disordering.</p>
</li>
</ul>
<h4 id="no-ordering-between-partitions"><a class="toclink" href="#no-ordering-between-partitions">No ordering between partitions</a></h4>
<ul>
<li>
<p>Make sure these <code>ProducerRecord</code>s be with the same partition</p>
<ul>
<li>
<p>Explicitly assigned with the same <code>topic-partition</code></p>
</li>
<li>
<p>Use the same <code>key</code> for these records</p>
</li>
</ul>
</li>
</ul>
<h3 id="idempotent-producer"><a class="toclink" href="#idempotent-producer">Idempotent Producer</a></h3>
<ul>
<li>
<p>The <code>enable.idempotence=true</code> configuration is highly <strong>RECOMMENDED</strong>.</p>
</li>
<li>
<p>Please refer to the <a href="https://github.com/confluentinc/librdkafka/blob/master/INTRODUCTION.md#idempotent-producer">document from librdkafkar</a> for more details.</p>
</li>
<li>
<p>Note: the Kafka cluster should be configured with <code>min.insync.replicas=2</code> at least</p>
</li>
</ul>
<h2 id="error-handling"><a class="toclink" href="#error-handling">Error handling</a></h2>
<p><code>Error</code> might occur at different places while sending a message,</p>
<ul>
<li>
<p>A <code>KafkaException</code> would be triggered if <code>KafkaProducer</code> failed to trigger the <code>send</code> operation.</p>
</li>
<li>
<p>Delivery <code>Error</code> would be passed through the delivery-callback.</p>
</li>
</ul>
<p>There are 2 cases for the <code>Error</code> <code>value()</code></p>
<ul>
<li>
<p>Local errors</p>
<ul>
<li>
<p><code>RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</code>      -- The topic doesn't exist</p>
</li>
<li>
<p><code>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</code>  -- The partition doesn't exist</p>
</li>
<li>
<p><code>RD_KAFKA_RESP_ERR__INVALID_ARG</code>        -- Invalid topic (topic is null or the length is too long (&gt;512))</p>
</li>
<li>
<p><code>RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</code>      -- No ack received within the time limit</p>
</li>
<li>
<p><code>RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</code>    -- The mesage size conflicts with local configuration <code>message.max.bytes</code></p>
</li>
</ul>
</li>
<li>
<p>Broker errors</p>
<ul>
<li>
<p><a href="https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-ErrorCodes">Error Codes</a></p>
</li>
<li>
<p>Typical errors are</p>
<ul>
<li>
<p>Invalid message: <code>RD_KAFKA_RESP_ERR_CORRUPT_MESSAGE</code>, <code>RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</code>, <code>RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</code>, <code>RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT</code>, <code>RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</code>.</p>
</li>
<li>
<p>Topic/Partition not exist: <code>RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</code>, -- automatic topic creation is disabled on the broker or the application is specifying a partition that does not exist.</p>
</li>
<li>
<p>Authorization failure: <code>RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</code>, <code>RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="frequently-asked-questions"><a class="toclink" href="#frequently-asked-questions">Frequently Asked Questions</a></h2>
<ul>
<li>
<p>About the automatic <code>topic creation</code></p>
<ul>
<li>
<p>If the cluster's configuration is with <code>auto.create.topics.enable=true</code>, the producer/consumer could trigger the brokers to create a new topic (with <code>send</code>, <code>subscribe</code>, etc)</p>
</li>
<li>
<p>Note: the default created topic may be not what you want (e.g, with <code>default.replication.factor=1</code> configuration as default, etc), thus causing other unexpected problems.</p>
</li>
</ul>
</li>
<li>
<p>How to enhance the sending performance?</p>
<ul>
<li>
<p>Enlarging the default <code>batch.num.messages</code> and <code>linger.ms</code> might improve message batching, thus enhancing the throughput. (while, on the other hand, <code>linger.ms</code> would highly impact the latency)</p>
</li>
<li>
<p>The <code>queue.buffering.max.messages</code> and <code>queue.buffering.max.kbytes</code> would determine the <code>max in flight requests (some materials about Kafka would call it in this way)</code>. If the queue buffer is full, the <code>send</code> operation would be blocked. Larger <code>queue.buffering.max.messages</code>/<code>queue.buffering.max.kbytes</code> might help to improve throughput, while also means more messages locally buffering.</p>
</li>
</ul>
</li>
<li>
<p>How many threads would be created by a KafkaProducer?</p>
<ul>
<li>
<p>Each broker (in the list of <code>bootstrap.servers</code>) would take a separate thread to transmit messages towards a kafka cluster server.</p>
</li>
<li>
<p>Another 2 threads would handle internal operations and kinds of timers, etc.</p>
</li>
<li>
<p>By default, <code>enable.manual.events.poll=false</code>, then one more background thread would be created, which keeps polling the delivery events and triggering the callbacks.</p>
</li>
</ul>
</li>
</ul>
      <hr/>
      <footer class="text-center text-muted">
        Generated: 2023. 01. 05
      </footer>
      <hr/>
    </div>
  </body>
</html>